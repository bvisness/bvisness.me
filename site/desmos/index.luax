local article = require("articles")["desmos"]
require("simplearticle")

function Head()
  return <>
    <!-- MathJax -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        "CommonHTML": { linebreaks: { automatic: true } },
        "HTML-CSS": { linebreaks: { automatic: true } },
        "SVG": { linebreaks: { automatic: true } }
      });
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'></script>

    <!-- Desmos -->
    <script src="https://www.desmos.com/api/v1.2/calculator.js?apiKey=dcb31709b452b1cf9dc26972add0fda6"></script>
    <script>
      var desmosConfigs = {};
      function desmosReset(id) {
        var elt = document.getElementById(id);
        elt.innerHTML = '';
        desmosConfigs[id]();
      }
    </script>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/102/three.js"></script>
    <script src={ bust(relurl("threegraph.js")) }></script>
    <script src={ bust(relurl("anim.js")) }></script>
  </>
end

local desmosID = 0

function ThreeGraph(atts, children)
    desmosID = desmosID + 1
    return <>
        <div class="threegraph" id={ "threegraph-"..desmosID }></div>
        <script>
            function initThreeGraph{{ desmosID }}() {
                var container = document.querySelector('#threegraph-{{ desmosID }}');
                var parent = container.parentNode;

                var scene = new THREE.Scene();

                var cameraAnchor = new THREE.Object3D();
                var camera = new THREE.PerspectiveCamera(
                    75,
                    parent.clientWidth / parent.clientHeight,
                    0.1,
                    1000
                );
                scene.add(cameraAnchor);
                cameraAnchor.add(camera);

                var renderer = null;
                function _makeRenderer() {
                    if (renderer) {
                        return false;
                    }

                    var canvas = document.createElement('canvas');
                    canvas.innerHTML = 'Animations are not supported in your browser.';
                    container.appendChild(canvas);

                    renderer = new THREE.WebGLRenderer({
                        canvas: canvas,
                        antialias: true,
                        alpha: true,
                    });
                    renderer.setClearColor(new THREE.Color(0xffffff), 0);

                    return true;
                }
                function _destroyRenderer() {
                    if (!renderer) {
                        return false;
                    }

                    renderer = null;
                    container.innerHTML = '';

                    return true;
                }

                function animate() {}

                {{ atts.js }}

                function _resizeRenderer() {
                    if (!renderer) {
                        return;
                    }

                    renderer.setPixelRatio(window.devicePixelRatio);
                    renderer.setSize(parent.clientWidth, parent.clientHeight);
                    camera.aspect = parent.clientWidth / parent.clientHeight;
                    camera.updateProjectionMatrix();
                }

                var baseTime = Date.now();
                var time = 0;

                function isOnscreen() {
                    var containerRect = container.getBoundingClientRect();
                    return containerRect.top < window.innerHeight && containerRect.bottom > 0;
                }

                function _animate() {
                    requestAnimationFrame( _animate );

                    var newTime = Date.now() - baseTime;
                    var dt = (newTime - time) / 1000;

                    animate(dt, newTime / 1000);

                    if (!isOnscreen()) {
                        return;
                    }

                    if (renderer) {
                        renderer.render( scene, camera );
                    }

                    time = newTime;
                }
                if (isOnscreen()) {
                    _makeRenderer();
                    _resizeRenderer();
                }
                _animate();

                window.addEventListener('resize', function() {
                    _resizeRenderer();
                });
                window.addEventListener('scroll', function() {
                    if (isOnscreen()) {
                        var didCreate = _makeRenderer();
                        if (didCreate) {
                            _resizeRenderer();
                        }
                    } else {
                        _destroyRenderer();
                    }
                });
            }
            document.addEventListener('DOMContentLoaded', function() {
                initThreeGraph{{ desmosID }}();
            });
        </script>
    </>
end

function Drawing(atts, children)
  return <div class="full-width-container">
    <div class="full-width">
      <div class="drawing">
        <Picture src={ relpath(atts.src) } scale={ 2 } />
      </div>
    </div>
  </div>
end

bhp.render(<SimpleArticle article={ article } head={ Head }>
  <span style="display: none">
  $$
  \DeclareMathOperator{\length}{length}
  \DeclareMathOperator{\mod}{mod}
  $$
  </span>

  <script>
    var cameraLocWide = new THREE.Vector3(0, 1.5, 3.5);
    var cameraLocSquare = new THREE.Vector3(0, 2, 4);
    var cameraTarget = new THREE.Vector3(0, -0.5, 0);

    var cubeSize = 0.65;
    var cubeColor = 0x3333ff;
    var cubeRotationX = toRadians(12);
    var cubeRotationY = toRadians(-90 + -20);

    var camVisualX = 1.25;
    var camVisualY = 0.5;
    var camVisualZ = 1.5;
    var camVisualRotX = toRadians(-20);
    var camVisualRotY = toRadians(40);
    var camVisualFOV = 90;

    var orbitSpeed = 0.25;
  </script>

  <p>
    A couple weeks ago, I was introduced to <a href="https://www.desmos.com/">Desmos</a>.
  </p>

  <p>
    Desmos is an online graphing calculator. It can plot lots of different types of functions in a really intuitive way. But its real hook is that all of its graphs are interactive. You can define a variable and Desmos will automatically make a slider so you can change that variable's value and see the result in real time. You can even click and drag points on the graph itself. It makes math so tangible and I love it.
  </p>

  <p>
    Within the first day of using Desmos, an idea entered my mind that I couldn't shake: if Desmos can make 2D graphs so interactive, could it do the same for 3D?
  </p>

  <p>
    It turns out, <a href="https://www.desmos.com/calculator/ersamusmyo">the answer is yes</a>.
  </p>

  <div class="aspect-4x3">
    <iframe src="https://www.desmos.com/calculator/ersamusmyo?embed" class="aspect-inside" style="border: 1px solid #ccc" frameborder="0"></iframe>
  </div>

  <p>
    Making this happen pushed the features of Desmos to the absolute limit. In this article I want to give a more detailed breakdown of how it's done.
  </p>

  <p>
    Before we get into Desmos itself, we need to cover the math of 3D rendering.
  </p>

  <h2>How does the math work?</h2>

  <p>
    At a high level, 3D rendering is just a long series of transformations. We want to take a set of points in 3D space and move, rotate, stretch, and flatten them until they're all where we want them in a 2D image. Before we can dig into the details of each transformation, though, we need to look at the big picture.
  </p>

  <p>
    Let's start with what we know:
  </p>

  <ul>
    <li>
      We're going to have a <em>model</em> to render, like the cube in my example. For me, the model is just a list of points in 3D space. The model can have its own position and rotation in the scene that we're going to render. (In my renderer, I only have controls for rotation.)
    </li>
    <li>
      We're also going to have a <em>camera</em>, which defines the point of view of the image. The camera will have its own position and rotation, plus some camera-specific stuff like a field of view.
    </li>
  </ul>

  <div class="aspect-16x9">
    <ThreeGraph js=[[
      camera.position.copy(cameraLocWide);

      camera.lookAt(cameraTarget);

      var cube = ThreeGraph.Cube(
        cubeSize,
        new THREE.LineBasicMaterial({ color: cubeColor })
      );
      cube.rotation.x = cubeRotationX;
      cube.rotation.y = cubeRotationY;
      scene.add(cube);

      scene.add(ThreeGraph.Axes(2));

      var camVisualAnchor = new THREE.Object3D();
      camVisualAnchor.position.x = camVisualX;
      camVisualAnchor.position.y = camVisualY;
      camVisualAnchor.position.z = camVisualZ;
      camVisualAnchor.rotation.order = "YXZ";
      camVisualAnchor.rotation.x = camVisualRotX;
      camVisualAnchor.rotation.y = camVisualRotY;
      scene.add(camVisualAnchor);

      var camVisual = ThreeGraph.Camera(camVisualFOV / 2, 16/9);
      camVisual.rotation.y = toRadians(180);
      camVisualAnchor.add(camVisual);

      ThreeGraph.RenderPoints(
        cube,
        ThreeGraph.Mat_Color(cubeColor)
      );

      function animate(dt, t) {
        cameraAnchor.rotation.y = wobble(t, 50, orbitSpeed);
      }
    ]] />
  </div>

  <p>
    So that's the information we start with. We end with 2D points laid out so that they form an image from the camera's point of view. How we get from start to finish goes through four stages. I'll call those stages <b>model space</b>, <b>world space</b>, <b>camera space</b>, and <b>projection space</b>.
  </p>

  <style>
    .fourspaces .columns {
      justify-content: center;
    }
    .fourspaces figure {
      min-width: 280px;
      max-width: 360px;
    }
    @media screen and (max-width: 1200px) {
      .fourspaces .full-width.columns {
        flex-wrap: wrap;
      }
    }
    @media screen and (max-width: 580px) {
      .fourspaces .columns {
        flex-wrap: wrap;
      }
      .fourspaces figure {
        max-width: 300px;
      }
    }
  </style>
  <div class="full-width-container fourspaces">
    <div class="full-width columns">
      <div class="column columns">
        <figure class="column">
          <div class="aspect-square">
            <ThreeGraph js=[[
              camera.position.copy(cameraLocSquare);

              camera.lookAt(cameraTarget);

              scene.add(ThreeGraph.Axes(2));

              var cube = ThreeGraph.Cube(
                cubeSize,
                new THREE.LineBasicMaterial({ color: cubeColor })
              );
              scene.add(cube);

              ThreeGraph.RenderPoints(
                cube,
                ThreeGraph.Mat_Color(cubeColor)
              );

              function animate(dt, t) {
                cameraAnchor.rotation.y = wobble(t, 50, orbitSpeed);
              }
            ]] />
          </div>
          <figcaption>Model Space</figcaption>
        </figure>
        <figure class="column">
          <div class="aspect-square">
            <ThreeGraph js=[[
              camera.position.copy(cameraLocSquare);

              camera.lookAt(cameraTarget);

              scene.add(ThreeGraph.Axes(2));

              var cube = ThreeGraph.Cube(
                cubeSize,
                new THREE.LineBasicMaterial({ color: cubeColor })
              );
              cube.rotation.x = cubeRotationX;
              cube.rotation.y = cubeRotationY;
              scene.add(cube);

              var camVisualAnchor = new THREE.Object3D();
              camVisualAnchor.position.x = camVisualX;
              camVisualAnchor.position.y = camVisualY;
              camVisualAnchor.position.z = camVisualZ;
              camVisualAnchor.rotation.order = "YXZ";
              camVisualAnchor.rotation.x = camVisualRotX;
              camVisualAnchor.rotation.y = camVisualRotY;
              scene.add(camVisualAnchor);

              var camVisual = ThreeGraph.Camera(camVisualFOV / 2, 16/9);
              camVisual.rotation.y = toRadians(180);
              camVisualAnchor.add(camVisual);

              ThreeGraph.RenderPoints(
                cube,
                ThreeGraph.Mat_Color(cubeColor)
              );

              function animate(dt, t) {
                cameraAnchor.rotation.y = wobble(t, 50, orbitSpeed);
              }
            ]] />
          </div>
          <figcaption>World Space</figcaption>
        </figure>
      </div>
      <div class="column columns">
        <figure class="column">
          <div class="aspect-square">
            <ThreeGraph js=[[
              camera.position.copy(cameraLocSquare);

              camera.lookAt(cameraTarget);

              scene.add(ThreeGraph.Axes(2));

              var cube = ThreeGraph.Cube(
                cubeSize,
                ThreeGraph.Mat_Color(cubeColor),
              );
              cube.rotation.x = cubeRotationX;
              cube.rotation.y = cubeRotationY;
              scene.add(cube);

              var camVisualAnchor = new THREE.Object3D();
              camVisualAnchor.position.x = camVisualX;
              camVisualAnchor.position.y = camVisualY;
              camVisualAnchor.position.z = camVisualZ;
              camVisualAnchor.rotation.order = "YXZ";
              camVisualAnchor.rotation.x = camVisualRotX;
              camVisualAnchor.rotation.y = camVisualRotY;
              scene.add(camVisualAnchor);

              var camVisual = ThreeGraph.Camera(camVisualFOV / 2, 16/9);
              camVisual.rotation.y = toRadians(180);
              camVisualAnchor.add(camVisual);

              var camInverse = ThreeGraph.InverseMatrixWorld(camVisualAnchor);

              // HACK! Can't be bothered to recompute this down below
              window.camInverse = camInverse;

              ThreeGraph.ApplyLocalTransform(cube, camInverse);
              ThreeGraph.ApplyLocalTransform(camVisualAnchor, camInverse);

              ThreeGraph.RenderPoints(
                cube,
                ThreeGraph.Mat_Color(cubeColor)
              );

              function animate(dt, t) {
                cameraAnchor.rotation.y = wobble(t, 50, orbitSpeed);
              }
            ]] />
          </div>
          <figcaption>Camera Space</figcaption>
        </figure>
        <figure class="column">
          <div class="aspect-square">
            <ThreeGraph js=[[
              camera.position.copy(cameraLocSquare);

              camera.lookAt(cameraTarget);

              scene.add(ThreeGraph.Axes(2));

              var cube = ThreeGraph.Cube(
                cubeSize,
                ThreeGraph.Mat_Color(cubeColor)
              );
              ThreeGraph.TransformVertices(
                cube,
                ThreeGraph.RotationXMatrix(cubeRotationX),
              );
              ThreeGraph.TransformVertices(
                cube,
                ThreeGraph.RotationYMatrix(cubeRotationY),
              );
              scene.add(cube);

              var proj = ThreeGraph.ProjectionMatrix(Math.PI / 2);

              ThreeGraph.TransformVertices(cube, window.camInverse);
              ThreeGraph.TransformVertices(
                cube,
                ThreeGraph.ProjectionMatrix(toRadians(camVisualFOV)),
              );

              ThreeGraph.RenderPoints(
                cube,
                ThreeGraph.Mat_Color(cubeColor)
              );

              function animate(dt, t) {
                cameraAnchor.rotation.y = wobble(t, 50, orbitSpeed);
              }
            ]] />
          </div>
          <figcaption>Projection Space</figcaption>
        </figure>
      </div>
    </div>
  </div>

  <p>  <strong>Model space</strong> is our starting point. The points of our model are centered around the origin (or the center of our world). When we create a model, we define all of its points in model space.</p>
  <p>  In <strong>world space</strong>, everything is placed where it belongs in our 3D scene. You can see that the model is rotated to a new orientation, and our camera has been moved and rotated to point at it.</p>
  <p>  In <strong>camera space</strong>, we shift everything in the scene so that the camera is at the center, pointing forward. We&#39;re effectively moving everything to the camera&#39;s point of view. This might seem like a surprising step, but it makes the next stage much easier.</p>
  <p>  Finally, in <strong>projection space</strong>, we flatten the world down from three dimensions to two. This is where the camera&#39;s field of view comes into play, because we use it to give our final image a sense of perspective.</p>
  <p>  Once we&#39;re in projection space, we are working in two dimensions! All that remains is to plot those 2D points and we have ourselves an image.</p>

  <div class="aspect-16x9">
    <ThreeGraph js=[[
      camera.position.copy(cameraLocWide);

      camera.lookAt(cameraTarget);

      var cube = ThreeGraph.Cube(
        cubeSize,
        ThreeGraph.Mat_Color(cubeColor),
      );
      scene.add(cube);

      ThreeGraph.RenderPoints(
        cube,
        ThreeGraph.Mat_Color(cubeColor),
      );

      scene.add(ThreeGraph.Axes(2));

      var camVisualAnchor = new THREE.Object3D();
      camVisualAnchor.rotation.order = "YXZ";
      camVisualAnchor.position.x = camVisualX;
      camVisualAnchor.position.y = camVisualY;
      camVisualAnchor.position.z = camVisualZ;
      camVisualAnchor.rotation.x = camVisualRotX;
      camVisualAnchor.rotation.y = camVisualRotY;
      scene.add(camVisualAnchor);

      var camVisual = ThreeGraph.Camera(camVisualFOV / 2, 16/9);
      camVisual.rotation.y = toRadians(180);
      camVisualAnchor.add(camVisual);

      var camInverse = ThreeGraph.InverseMatrixWorld(camVisualAnchor);

      var sequence = new Sequence(
        {
          cubeOpacity: 0,
          camOpacity: 0,
        },
        [
          {
            duration: 1.5,
            easingFunction: Easing.easeInOutQuad,
            values: {
              cRotX: 0,
              cRotY: 0,
              cubeOpacity: 1,
              camOpacity: 1,
            },
            init: function() {
              resetVerts(cube);
              resetPoints(cube);

              camVisualAnchor.position.x = camVisualX;
              camVisualAnchor.position.y = camVisualY;
              camVisualAnchor.position.z = camVisualZ;
              camVisualAnchor.rotation.x = camVisualRotX;
              camVisualAnchor.rotation.y = camVisualRotY;
            },
            f: function(vals, st) {
              setOpacity(cube, vals.cubeOpacity);
              setOpacity(camVisual, vals.camOpacity);
            },
          },
          {
            duration: 3,
            easingFunction: Easing.easeInOutQuad,
            values: {
              cRotX: cubeRotationX,
              cRotY: cubeRotationY,
              camPosition: new THREE.Vector3(camVisualX, camVisualY, camVisualZ),
              camRotation: new THREE.Vector3(camVisualRotX, camVisualRotY, 0),
            },
            f: function(vals, st) {
              var rotX = ThreeGraph.RotationXMatrix(vals.cRotX);
              var rotY = ThreeGraph.RotationYMatrix(vals.cRotY);
              function transformed(vert) {
                return vert.clone().applyMatrix4(rotX).applyMatrix4(rotY);
              }

              transformVerts(cube, function(orig) {
                return transformed(orig);
              });
              transformPoints(cube, function(point) {
                point.position.copy(transformed(point.originalPosition));
              });
            },
          },
          {
            duration: 3,
            easingFunction: Easing.easeInOutQuad,
            values: {
              cRotX: cubeRotationX,
              cRotY: cubeRotationY,
              camPosition: new THREE.Vector3(0, 0, 0),
              camRotation: new THREE.Vector3(0, 0, 0),
              camOpacity: 1,
            },
            f: function(vals, st) {
              var rotX = ThreeGraph.RotationXMatrix(vals.cRotX);
              var rotY = ThreeGraph.RotationYMatrix(vals.cRotY);
              function transformed(vert) {
                var before = vert.clone()
                  .applyMatrix4(rotX)
                  .applyMatrix4(rotY);
                var after = before.clone()
                  .applyMatrix4(camInverse);
                return before.clone().lerp(after, st);
              }

              transformVerts(cube, function(orig) {
                return transformed(orig);
              });
              transformPoints(cube, function(point) {
                point.position.copy(transformed(point.originalPosition));
              });

              camVisualAnchor.position.copy(vals.camPosition);
              camVisualAnchor.rotation.x = vals.camRotation.x;
              camVisualAnchor.rotation.y = vals.camRotation.y;
            },
          },
          {
            duration: 3,
            easingFunction: Easing.easeInOutQuad,
            values: {
              cRotX: cubeRotationX,
              cRotY: cubeRotationY,
              camOpacity: 0,
            },
            f: function(vals, st) {
              var rotX = ThreeGraph.RotationXMatrix(vals.cRotX);
              var rotY = ThreeGraph.RotationYMatrix(vals.cRotY);
              var proj = ThreeGraph.ProjectionMatrix(toRadians(camVisualFOV));
              function transformed(vert) {
                var before = vert.clone()
                  .applyMatrix4(rotX)
                  .applyMatrix4(rotY)
                  .applyMatrix4(camInverse);
                var after = before.clone()
                  .applyMatrix4(proj);
                return before.clone().lerp(after, st);
              }

              transformVerts(cube, function(orig) {
                return transformed(orig);
              });
              transformPoints(cube, function(point) {
                point.position.copy(transformed(point.originalPosition));
              });

              setOpacity(camVisual, vals.camOpacity);
            },
          },
          {
            duration: 3,
            values: {
              cubeOpacity: 1,
            },
            f: function() {},
          },
          {
            duration: 1.5,
            values: {
              cubeOpacity: 0,
            },
            f: function(vals) {
              setOpacity(cube, vals.cubeOpacity);
            },
          },
        ]
      );

      function animate(dt, t) {
        cameraAnchor.rotation.y = wobble(t, 60, 0.2);
        sequence.do(t % sequence.totalDuration);
      }
    ]] />
  </div>

  <p>Now let&#39;s get into the nitty-gritty of how to do this.</p>

  <h3 id="some-small-prerequisites">Some small prerequisites</h3>

  <p>  Graphics math is all about vectors and matrices. In our case, we use vectors to represent the points of our model and matrices to represent ways of transforming them. If you&#39;ve never encountered vectors before, the best way to get up to speed is 3blue1brown&#39;s excellent <a href="https://www.youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab">Essence of Linear Algebra</a> series on Youtube. For what we&#39;re doing, you only need the information from the first four videos, which should take you less than an hour to get through.</p>

  <p>  You really should watch those videos; they explain the basics far better than I can. But here&#39;s my whirlwind summary of the parts we&#39;ll be using:</p>

  <ul>
    <li>
      <p>We&#39;ll use vectors to represent the points of our model. Although our points are all three-dimensional, we actually will be using four-dimensional vectors to represent them. The first three components will be the x, y, and z of the point as you would expect. The last component of the vector will just be the number 1. For example, a 3D point with an X position of 1, a Y position of 2, and a Z position of 3 would look like:</p>
      <p><Drawing src="images/prereq-vec.png" /></p>
    </li>
    <li>
      <p>We&#39;ll use matrices to represent transformations. I&#39;m omitting the details, but for example, a matrix that rotates vectors by 90Â° around the y axis would look like:</p>
      <p><Drawing src="images/prereq-mat.png" /></p>
    </li>
    <li>
      <p>Multiplying a vector by a matrix transforms that vector accordingly. For example, here is what it looks like to rotate our example vector by 90 degrees around the Y axis, color-coded so it&#39;s easier to follow:</p>
      <p><Drawing src="images/prereq-mult.png" /></p>
      <p>  If you have never seen this kind of multiplication before, I recommend trying to see how this one fits together. I&#39;ll be glossing over some details throughout this article, but parts of it will still make more sense if you have an idea of how this works.</p>
    </li>
  </ul>
  <p>  Also, it probably seems strange to use four-dimensional vectors to represent three-dimensional data, but the reason we do it is pretty interesting. The short version is that we can do a clever trick with a fourth dimension to do some transformations that wouldn&#39;t otherwise be possible with matrices. The long version will have to wait for another blog post, but if you&#39;re impatient, just look up &quot;homogeneous coordinates&quot;.</p>
  <h3 id="model-space-to-world-space">Model space to world space</h3>

  <div class="aspect-16x9">
    <ThreeGraph js=[[
      camera.position.copy(cameraLocWide);

      camera.lookAt(cameraTarget);

      var cube = ThreeGraph.Cube(
        cubeSize,
        ThreeGraph.Mat_Color(cubeColor),
      );
      scene.add(cube);

      ThreeGraph.RenderPoints(
        cube,
        ThreeGraph.Mat_Color(cubeColor),
      );

      scene.add(ThreeGraph.Axes(2));

      var sequence = new Sequence(
        {
          cubeOpacity: 0,
        },
        [
          {
            duration: 1.5,
            easingFunction: Easing.easeInOutQuad,
            values: {
              cRotX: 0,
              cubeOpacity: 1,
            },
            init: function() {
              resetVerts(cube);
              resetPoints(cube);
            },
            f: function(vals, st) {
              setOpacity(cube, vals.cubeOpacity);
            },
          },
          {
            duration: 0.75,
            easingFunction: Easing.easeInOutQuad,
            values: {
              cRotX: cubeRotationX,
              cRotY: 0,
            },
            f: function(vals, st) {
              var rotX = ThreeGraph.RotationXMatrix(vals.cRotX);
              var rotY = ThreeGraph.RotationYMatrix(vals.cRotY);
              function transformed(vert) {
                return vert.clone().applyMatrix4(rotX).applyMatrix4(rotY);
              }

              transformVerts(cube, function(orig) {
                return transformed(orig);
              });
              transformPoints(cube, function(point) {
                point.position.copy(transformed(point.originalPosition));
              });
            },
          },
          {
            duration: 3,
            easingFunction: Easing.easeInOutQuad,
            values: {
              cRotX: cubeRotationX,
              cRotY: cubeRotationY,
            },
            f: function(vals, st) {
              var rotX = ThreeGraph.RotationXMatrix(vals.cRotX);
              var rotY = ThreeGraph.RotationYMatrix(vals.cRotY);
              function transformed(vert) {
                return vert.clone().applyMatrix4(rotX).applyMatrix4(rotY);
              }

              transformVerts(cube, function(orig) {
                return transformed(orig);
              });
              transformPoints(cube, function(point) {
                point.position.copy(transformed(point.originalPosition));
              });
            },
          },
          {
            duration: 3,
            values: {
              cubeOpacity: 1,
            },
            f: function() {},
          },
          {
            duration: 1.5,
            values: {
              cubeOpacity: 0,
            },
            f: function(vals) {
              setOpacity(cube, vals.cubeOpacity);
            },
          },
        ]
      );

      function animate(dt, t) {
        cameraAnchor.rotation.y = wobble(t, 60, 0.2);
        sequence.do(t % sequence.totalDuration);
      }
    ]] />
  </div>

  <p>The first major transformation is going from model space to world space, where the model gets placed into our overall scene. For my renderer, I chose to do just two rotations, since it made the controls easy. I first rotate the model about the X axis, then about the Y axis - you could do the rotations in a different order, but I liked the results I got with that.</p>
  <p>  Order matters when multiplying vectors and matrices - we always have the matrix on the left and the vector on the right. But this means that a series of transformations gets built up from right to left, instead of left to right as you might expect. To rotate first by X, then by Y, our equation will look like:</p>
  <p>  <Drawing src="images/eq-model2world.png" /></p>
  <p>  A more general-purpose renderer could add lots more to this step - for example, moving the model around in space, rotating along the Z axis, or scaling it up and down. But a little rotation is enough for now.</p>

  <h3 id="world-space-to-camera-space">World space to camera space</h3>

  <div class="aspect-16x9">
    <ThreeGraph js=[[
      camera.position.copy(cameraLocWide);

      camera.lookAt(cameraTarget);

      var cube = ThreeGraph.Cube(
        cubeSize,
        ThreeGraph.Mat_Color(cubeColor),
      );
      scene.add(cube);

      ThreeGraph.RenderPoints(
        cube,
        ThreeGraph.Mat_Color(cubeColor),
      );

      var camVisualAnchor = new THREE.Object3D();
      camVisualAnchor.rotation.order = "YXZ";
      camVisualAnchor.position.x = camVisualX;
      camVisualAnchor.position.y = camVisualY;
      camVisualAnchor.position.z = camVisualZ;
      camVisualAnchor.rotation.x = camVisualRotX;
      camVisualAnchor.rotation.y = camVisualRotY;
      scene.add(camVisualAnchor);

      var camVisual = ThreeGraph.Camera(camVisualFOV / 2, 16/9);
      camVisual.rotation.y = toRadians(180);
      camVisualAnchor.add(camVisual);

      var camInverse = ThreeGraph.InverseMatrixWorld(camVisualAnchor);

      scene.add(ThreeGraph.Axes(2));

      var sequence = new Sequence(
        {
          cubeOpacity: 0,
          camOpacity: 0,
        },
        [
          {
            duration: 1.5,
            easingFunction: Easing.easeInOutQuad,
            values: {
              cubeOpacity: 1,
              camOpacity: 1,
              camPosition: new THREE.Vector3(camVisualX, camVisualY, camVisualZ),
              camRotation: new THREE.Vector3(camVisualRotX, camVisualRotY, 0),
            },
            init: function() {
              var rotX = ThreeGraph.RotationXMatrix(cubeRotationX);
              var rotY = ThreeGraph.RotationYMatrix(cubeRotationY);
              function transformed(vert) {
                return vert.clone().applyMatrix4(rotX).applyMatrix4(rotY);
              }

              transformVerts(cube, function(orig) {
                return transformed(orig);
              });
              transformPoints(cube, function(point) {
                point.position.copy(transformed(point.originalPosition));
              });

              camVisualAnchor.position.x = camVisualX;
              camVisualAnchor.position.y = camVisualY;
              camVisualAnchor.position.z = camVisualZ;
              camVisualAnchor.rotation.x = camVisualRotX;
              camVisualAnchor.rotation.y = camVisualRotY;
            },
            f: function(vals, st) {
              setOpacity(cube, vals.cubeOpacity);
              setOpacity(camVisual, vals.cubeOpacity);
            },
          },
          {
            duration: 3,
            easingFunction: Easing.easeInOutQuad,
            values: {
              camPosition: new THREE.Vector3(0, 0, 0),
              camRotation: new THREE.Vector3(0, 0, 0),
            },
            f: function(vals, st) {
              var rotX = ThreeGraph.RotationXMatrix(cubeRotationX);
              var rotY = ThreeGraph.RotationYMatrix(cubeRotationY);
              function transformed(vert) {
                var before = vert.clone()
                  .applyMatrix4(rotX)
                  .applyMatrix4(rotY);
                var after = before.clone()
                  .applyMatrix4(camInverse);
                return before.clone().lerp(after, st);
              }

              transformVerts(cube, function(orig) {
                return transformed(orig);
              });
              transformPoints(cube, function(point) {
                point.position.copy(transformed(point.originalPosition));
              });

              camVisualAnchor.position.copy(vals.camPosition);
              camVisualAnchor.rotation.x = vals.camRotation.x;
              camVisualAnchor.rotation.y = vals.camRotation.y;
            },
          },
          {
            duration: 3,
            values: {
              cubeOpacity: 1,
              camOpacity: 1,
            },
            f: function() {},
          },
          {
            duration: 1.5,
            values: {
              cubeOpacity: 0,
              camOpacity: 0,
            },
            f: function(vals) {
              setOpacity(cube, vals.cubeOpacity);
              setOpacity(camVisual, vals.cubeOpacity);
            },
          },
        ]
      );

      function animate(dt, t) {
        cameraAnchor.rotation.y = wobble(t, 60, 0.2);
        sequence.do(t % sequence.totalDuration);
      }
    ]] />
  </div>

  <p>We now have to go from world space to camera space, where the camera is at the center. This is very similar to our last step - but there&#39;s a twist.</p>
  <p>  In the last step, our model started at the origin and we moved it somewhere else. This time, our camera is somewhere else and we want to move it <em>back</em> to the origin. This means that we need to find the transformations that would move the camera to the right place, but then do those transformations in reverse.</p>
  <p>  To show you why this works, let&#39;s step back to two dimensions for a bit. Say we want to shift everything in this picture so that the blue triangle is at the origin. It&#39;s at the coordinates \(\begin{bmatrix}1 \ 2\end{bmatrix}\). What transformation do we have to do to put it back?</p>
  <p>  <Drawing src="images/shapes-before.png" /></p>
  <p>  Since the triangle is right by 1 and up by 2, we need to shift everything <em>left</em> by 1 and <em>down</em> by 2. If the coordinates are \(\begin{bmatrix}1 \ 2\end{bmatrix}\), the transformation we need to do is \(\begin{bmatrix}-1 \ -2\end{bmatrix}\).</p>
  <p>  <Drawing src="images/shapes-after.png" /></p>
  <p>  This applies to rotations too. If the triangle were rotated by by 30 degrees, we would need to rotate it by -30 degrees to undo the rotation.</p>
  <p>  Let&#39;s jump back to our scene now. The camera in our scene has been moved and rotated. The sequence of transformations to move it to the right place is: Rotate X, Rotate Y, Move. To undo those transformations, we do: Move, Rotate Y, Rotate X.</p>

  <div class="aspect-16x9">
    <ThreeGraph js=[[
      camera.position.copy(cameraLocWide);

      camera.lookAt(cameraTarget);

      var cube = ThreeGraph.Cube(
        cubeSize,
        ThreeGraph.Mat_Color(cubeColor),
      );
      scene.add(cube);

      ThreeGraph.RenderPoints(
        cube,
        ThreeGraph.Mat_Color(cubeColor),
      );

      var camVisualAnchor = new THREE.Object3D();
      camVisualAnchor.rotation.order = "YXZ";
      scene.add(camVisualAnchor);

      var camVisual = ThreeGraph.Camera(camVisualFOV / 2, 16/9);
      camVisual.rotation.y = toRadians(180);
      camVisualAnchor.add(camVisual);

      scene.add(ThreeGraph.Axes(2));

      function transformAll(vals, st) {
        setOpacity(cube, vals.cubeOpacity);
        setOpacity(camVisual, vals.camOpacity);

        camVisualAnchor.position.copy(vals.camPosition);
        camVisualAnchor.rotation.x = vals.camRotation.x;
        camVisualAnchor.rotation.y = vals.camRotation.y;

        var rotX = ThreeGraph.RotationXMatrix(cubeRotationX);
        var rotY = ThreeGraph.RotationYMatrix(cubeRotationY);
        var cRotXInverse = ThreeGraph.RotationXMatrix(vals.camRotation.x);
        var cRotYInverse = ThreeGraph.RotationYMatrix(vals.camRotation.y);
        var cMoveInverse = ThreeGraph.TranslationMatrix(vals.camPosition);
        function transformed(vert) {
          return vert.clone()
            .applyMatrix4(rotX)
            .applyMatrix4(rotY)
            .applyMatrix4(window.camInverse)
            .applyMatrix4(cRotXInverse)
            .applyMatrix4(cRotYInverse)
            .applyMatrix4(cMoveInverse)
        }

        transformVerts(cube, function(orig) {
          return transformed(orig);
        });
        transformPoints(cube, function(point) {
          point.position.copy(transformed(point.originalPosition));
        });
      }

      var sequence = new Sequence(
        {
          cubeOpacity: 0,
          camOpacity: 0,
          camPosition: new THREE.Vector3(0, 0, 0),
          camRotation: new THREE.Vector3(0, 0, 0),
        },
        [
          {
            duration: 1.5,
            easingFunction: Easing.easeInOutQuad,
            values: {
              cubeOpacity: 0,
              camOpacity: 1,
              camPosition: new THREE.Vector3(0, 0, 0),
              camRotation: new THREE.Vector3(0, 0, 0),
            },
            f: transformAll,
          },
          {
            duration: 0.75,
            easingFunction: Easing.easeInOutQuad,
            values: {
              cubeOpacity: 0,
              camOpacity: 1,
              camPosition: new THREE.Vector3(0, 0, 0),
              camRotation: new THREE.Vector3(camVisualRotX, 0, 0),
            },
            f: transformAll,
          },
          {
            duration: 0.75,
            easingFunction: Easing.easeInOutQuad,
            values: {
              cubeOpacity: 0,
              camOpacity: 1,
              camPosition: new THREE.Vector3(0, 0, 0),
              camRotation: new THREE.Vector3(camVisualRotX, camVisualRotY, 0),
            },
            f: transformAll,
          },
          {
            duration: 1.5,
            easingFunction: Easing.easeInOutQuad,
            values: {
              cubeOpacity: 0,
              camOpacity: 1,
              camPosition: new THREE.Vector3(camVisualX, camVisualY, camVisualZ),
              camRotation: new THREE.Vector3(camVisualRotX, camVisualRotY, 0),
            },
            f: transformAll,
          },
          {
            duration: 0.5,
            easingFunction: Easing.easeInOutQuad,
            values: {
              cubeOpacity: 0,
              camOpacity: 1,
              camPosition: new THREE.Vector3(camVisualX, camVisualY, camVisualZ),
              camRotation: new THREE.Vector3(camVisualRotX, camVisualRotY, 0),
            },
            f: function() {},
          },
          {
            duration: 1.5,
            easingFunction: Easing.easeInOutQuad,
            values: {
              cubeOpacity: 1,
              camOpacity: 1,
              camPosition: new THREE.Vector3(camVisualX, camVisualY, camVisualZ),
              camRotation: new THREE.Vector3(camVisualRotX, camVisualRotY, 0),
            },
            f: transformAll,
          },
          {
            duration: 1.5,
            easingFunction: Easing.easeInOutQuad,
            values: {
              cubeOpacity: 1,
              camOpacity: 1,
              camPosition: new THREE.Vector3(0, 0, 0),
              camRotation: new THREE.Vector3(camVisualRotX, camVisualRotY, 0),
            },
            f: transformAll,
          },
          {
            duration: 0.75,
            easingFunction: Easing.easeInOutQuad,
            values: {
              cubeOpacity: 1,
              camOpacity: 1,
              camPosition: new THREE.Vector3(0, 0, 0),
              camRotation: new THREE.Vector3(camVisualRotX, 0, 0),
            },
            f: transformAll,
          },
          {
            duration: 0.75,
            easingFunction: Easing.easeInOutQuad,
            values: {
              cubeOpacity: 1,
              camOpacity: 1,
              camPosition: new THREE.Vector3(0, 0, 0),
              camRotation: new THREE.Vector3(0, 0, 0),
            },
            f: transformAll,
          },
          {
            duration: 1.5,
            easingFunction: Easing.easeInOutQuad,
            values: {
              cubeOpacity: 1,
              camOpacity: 1,
              camPosition: new THREE.Vector3(0, 0, 0),
              camRotation: new THREE.Vector3(0, 0, 0),
            },
            f: function() {},
          },
          {
            duration: 1.5,
            easingFunction: Easing.easeInOutQuad,
            values: {
              cubeOpacity: 0,
              camOpacity: 0,
              camPosition: new THREE.Vector3(0, 0, 0),
              camRotation: new THREE.Vector3(0, 0, 0),
            },
            f: transformAll,
          },
        ]
      );

      function animate(dt, t) {
        cameraAnchor.rotation.y = wobble(t, 60, 0.2);
        sequence.do(t % sequence.totalDuration);
      }
    ]] />
  </div>

  <p>  Our equation to move a vector \(\vec{v}\) from world space to camera space is therefore:</p>
  <p>  <Drawing src="images/eq-world2camera.png" /></p>
  <p>  And our whole equation so far is:</p>
  <p>  <Drawing src="images/eq-2camera.png" /></p>
  
  <h3 id="camera-space-to-projection-space">Camera space to projection space</h3>

</SimpleArticle>)
